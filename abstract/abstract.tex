%! Author = brdvlami
%! Date = 30/04/2024

% Preamble
\documentclass[10pt]{article}

% Packages
\usepackage[english]{babel}
\usepackage{subfloat}
\usepackage{float}
\usepackage[style=ieee, backend=biber]{biblatex}
\addbibresource{abstract_bibliography.bib}
\renewcommand*{\bibfont}{\footnotesize}


\usepackage{multicol}
\usepackage{caption}
\usepackage[hyperfootnotes=true]{hyperref}
\usepackage{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
%\setlength{\parindent}{0em}
\usepackage{geometry}
\geometry{
    a4paper,
    left=15mm,
    right=15mm,
    top=15mm,
    bottom=25mm,
}
\usepackage{graphicx}
\graphicspath{{./figures/}}

\newenvironment{Figure}
{\par\medskip\noindent\minipage{\linewidth}}
{\endminipage\par\medskip}


\newenvironment{Table}
{\par\medskip\noindent\minipage{\linewidth}}
{\endminipage\par\medskip}

\babelhyphenation[english]{Uni-Prot-KB}

% Document
\begin{document}

    \begingroup
    \centering
    \LARGE Unipept 6.0: Fast semi-exact peptide matching with a memory conservative index for UniProtKB\\[1em]
    \large Bram Devlaminck\\[2em]
    \endgroup

    \begin{multicols}{2}
        \section*{Abstract}\label{sec:test-section}


        \section{Introduction}\label{sec:introduction}
        Traditionally, the most used protease in the (meta)proteomics field is trypsin.
        Because of this, Unipept~\cite{unipept_desktop, unipept_api, unipept_4, unipept_orig, unipept_tutorial, unipept_web, unipept_cli, unipept_desktop_2} was specifically developed with this in mind.
        This resulted in the use of an index structure where the UniProtKB~\cite{UniprotKB} database is preprocessed by splitting every protein according to the cleavage pattern that trypsin creates.
        This also allows Unipept to precompute the LCA for every possible combination of matching tryptic peptides.
        This approach has proven its efficiency in the past few years, but also has its limitations.

        Trypsin will from time to time miss a cleavage position, this creates a so-called missed cleavage.
        Peptides with such missed cleavages will not be present in the current Unipept index, since Unipept assumes that there are no missed cleavages.
        To solve this problem, a solution was retro-fitted to handle these missed cleavages.
        When this option is selected, Unipept will scan the input peptide for these missed cleavage positions, split the peptide and perform separate lookups for every tryptic peptide.
        These results are intersected, which delivers a set of possible protein matches.
         Every protein in this set is brute-force scanned to ensure that the complete original peptide is present, and not only the separate tryptic fragments.
        Finally, the LCA of the found proteins is calculated on-the-fly.
        All these extra steps, including the on-the-fly calculation of the LCA has a significant impact on the performance when this option is enabled.

        A second disadvantage of the current Unipept index is the inability to process non-tryptic peptides.
        Similar to peptides with missed cleavages, these will not be present in the index, but there exists no workaround for this.

        This restriction has not been a significant problem since Unipept was originally created for the metaproteomics field, where trypsin is widely used.
        However, other fields such as the immunopeptidomics field frequently work with non-tryptic peptides.
        We aspire to broaden the use cases of Unipept, which requires a new search index with the following properties:

        \begin{enumerate}
            \item For every peptide (tryptic or non-tryptic), all matches in UniProtKB should be found.
            \item We need to be able to build the index for the full UniProtKB database with maximum memory usage around 1 to 2 TB of RAM\@.
            \item Search performance should be on par with the current Unipept index.
            \item The new index needs to be able to replace the current index, and facilitate all the current Unipept features.
        \end{enumerate}

        In short, we want an index that does not remove any of the current features, while remove the restriction that only tryptic peptides can efficiently be found by the current index.
        This also means that our new index will need to provide a way to equalize the amino acids isoleucine and leucine, as this is one of the current features.

        \section{Methods}\label{sec:methods}
        Our new index structure makes use of a suffix array.
        This suffix array can be build using the libdivsufsort~\cite{libdivsufsort} or libsais~\cite{libsais} library.
        Both provide a linear time algorithm with a $5n + O(1)$ memory complexity, where $n$ is the size of the text that needs to be indexed.

        \subsection{Sparse Suffix Arrays}
        While a complete suffix array delivers the best performance, the index itself is large.
        Since we are never interested in searching peptides that are less than 5 amino acids long\footnote{This is already a restriction in the current Unipept index, that has almost no real-world information loss associated with it because short peptides have thousands of matches, which makes the analysis results undetailed.}, we can make the suffix array sparse, which makes the resulting index smaller.
        This is accomplished by sampling the full suffix array, and only keeping every k-th suffix of the input text.
        This results in a sparse suffix array (SSA) which is only $\frac{1}{k}$th of the original suffix array size.

        \subsection{Equalizing Isoleucine and Leucine}
        Our solution to treat isoleucine and leucine as equal consists out of 2 parts.
        Firstly, we don't index the original text, but a slightly modified version.
        We replace every occurrence of Leucine by Isoleucine, which essentially equalizes them during the construction of the suffix array.
        During the search, we perform the same translation on every peptide, and as a result we find every match with I and L equalized.
        We perform this search using the original, unmodified text.
        This is important, since we need this original text when we need to perform a search operation were we do not want to equalize I and L\@.
        In this case a second step is added.

        During this second step, we filter away the wrong matches from the first stage.
        This is achieved by checking every I and L location in the original, unmodified peptide with the matching amino acid in the original text.
        When these two characters are the same, there is indeed an exact match.
        A mismatch indicates that I and L were wrongfully equalized.
        Only these I and L locations have to be checked since the suffix array search already ensures that all other characters match in the original text.


        \section{Results}\label{sec:results} % TODO: mention hardware specifics
        Three main aspects are considered during testing.
        The memory usage and speed during building, the resulting index size while hosting and search performance.

        \subsection{Building the Index}
        Building the suffix array for the complete UniProtKB database requires around 735 GB of RAM and 5 hours of computing time using the libdivsufsort library.
        Because of the high-memory needs, we use the HPC of Ghent University, where the high-memory cluster has 16 nodes with each 2\times 64-core AMD EPYC 7773X (Milan-X @ 2.2 GHz) and 940 GB of RAM\@.
        We use one core of a single node since the construction phase is single threaded.
        The resulting full suffix array is around 700 GB large (+ another 88 GB for the text).
        Our goal is to host this new index on Unipept servers, which have around 0.5 TB of available memory.
        To make this possible, we immediately perform a sampling phase with sparseness factor $k = 3$ at the end of the construction process on the HPC\@.
        This results in a search index size of $\frac{700}{3} + 88 \approx 322$ GB\@.
        Next to this search index Unipept needs some extra information (such as the UniProt accession number, NCBI taxon ID and functional annotations per protein).
        This results in another 25 GB of needed RAM\@.

        \begin{Figure}
            \centering
            \resizebox{\textwidth}{!}{
            \includegraphics{uniprot_memory_treemap}
            }
            \captionof{figure}{Visualisation of the size of each part of the new Unipept index for UniProtKB 2024\_01.}
            \label{fig:uniprot_memory_treemap}
        \end{Figure}

        \subsection{Querying the index}
        TODO: gebruik SIHUMIx files



        \section{Comparison}\label{sec:comparison}
        To compare our new index we need to take multiple aspects in to account.
        Tools such as the Uniprot peptide search tool~\cite{uniprot_search_site, uniprot_search_paper}, the Expasy ScanProsite tool~\cite{scanprosite} and Unipept at the moment all have the possibility to find matches in the UniProtKB database.
        There are some major differences though.

        Feature wise, the UniProt Peptide Search tool is identical to the new suffix array index developed for Unipept.
        They can both find all matches in UniProtKB, and have the option to equalize I and L\@.
        The only difference is the performance.
        Searching one peptide in the SA only takes a few milliseconds, while the UniProt tool takes a few seconds up to multiple minutes.

        Expasy ScanProsite tool takes another approach.
        They provide a wide range of options for inexact matching.
        They call this motives, ant these are comparable to regular expressions where the user can use wildcards, character classes and even negations.
        The other major difference is that this tool does not use the whole UniProtKB database.
        Only the proteins that are part of a reference genome are indexed, which means that less matches are found.

        The last major tool we compare with is the current Unipept index.
        As described in the introduction we wanted to keep all the current features of Unipept, with the addition of removing the restriction where Unipept can only quickly find tryptic peptides (or with a performance penalty also tryptic peptides with missed cleavages).
        This means that every non-tryptic peptide will result in 0 matches in the old index, while the new index will find all matches that are in UniProtKB\@.
        Table~\ref{tab:tool_comparison} gives a small overview of the described differences between the tools.

        \begin{Table}
            \centering
            \resizebox{\textwidth}{!}{
                \begin{tabular}{ l l l l l }
                    & SSA    & UPS          & ESP        & UP             \\
                    \hline\hline
                    Used Prot.   & all    & all          & ref. prot. & all            \\
                    Approx Match & [IL]   & [IL]         & flexible   & [IL]           \\
                    time         & $<$ 5 ms & 1 s - 20 min & 5 min      & $<$ 5 ms         \\
                    Valid pept.  & all    & all          & all        & $\sim$ tryptic \\
                    \hline
                \end{tabular}
            }
            \captionof{table}{Comparison of the new suffix array (SA), UniProt Peptide Search (UPS) tool, Expasy ScanProSite (ESP) tool and the current Unipept (UP) index.}
            \label{tab:tool_comparison}
        \end{Table}

%        \section{Discussion}\label{sec:discussion}

        \printbibliography[heading=bibintoc]
    \end{multicols}




\end{document}